
Paramtypes explained
====================

Internally in the SQLite database on disk, data are registered as being
of one of (currently) three allowed types:

-  ``numeric``
-  ``array``
-  ``text``

This notebook seeks to exemplify when each type should be used, and how
the ``Measurement`` object treats data of each type differently.

.. code:: ipython3

    import os
    
    import numpy as np
    
    from qcodes.instrument.parameter import ArrayParameter, Parameter
    from qcodes.dataset.database import initialise_or_create_database_at
    from qcodes.dataset.experiment_container import new_experiment
    from qcodes.dataset.measurements import Measurement
    from qcodes.dataset.data_set import load_by_id
    from qcodes.dataset.data_export import get_data_by_id
    from qcodes.tests.instrument_mocks import DummyInstrument
    import time

.. code:: ipython3

    initialise_or_create_database_at(os.path.join(os.getcwd(), 'paramtypes_explained.db'))
    new_experiment('paramtypes', sample_name='not_available')




.. parsed-literal::

    paramtypes#not_available#1@/home/travis/build/QCoDeS/Qcodes/docs/examples/DataSet/paramtypes_explained.db
    ---------------------------------------------------------------------------------------------------------



.. code:: ipython3

    dac = DummyInstrument('dac', gates=['ch1', 'ch2'])
    SA = DummyInstrument('SA')

.. code:: ipython3

    # some array-like data types
    
    class Spectrum(ArrayParameter):
        
        def __init__(self, name, instrument):
            
            self.N = 7
            setpoints = (np.linspace(0, 1, self.N),)
        
            super().__init__(name=name,
                             instrument=instrument,
                             setpoints=setpoints,
                             shape=(20,),
                             label='Noisy spectrum',
                             unit='V/sqrt(Hz)',
                             setpoint_names=('Frequency',),
                             setpoint_units=('Hz',))
            
        def get_raw(self):
            return np.random.randn(self.N)
        
    
    class MultiDimSpectrum(ArrayParameter):
        
        def __init__(self, name, instrument):
            self.start = 0
            self.stop = 1
            self.npts = (2, 5, 3)
            sp1 = np.linspace(self.start, self.stop,
                              self.npts[0])
            sp2 = np.linspace(self.start, self.stop,
                              self.npts[1])
            sp3 = np.linspace(self.start, self.stop,
                              self.npts[2])
            setpoints = (sp1,
                         np.tile(sp2, (len(sp1), 1)),
                         np.tile(sp3, (len(sp1), len(sp2), 1)))
            super().__init__(name=name,
                             instrument=instrument,
                             setpoints=setpoints,
                             shape=(100, 50, 20),
                             label='Flower Power Spectrum in 3D',
                             unit='V/sqrt(Hz)',
                             setpoint_names=('Frequency0', 'Frequency1',
                                             'Frequency2'),
                                 setpoint_units=('Hz', 'Other Hz', "Third Hz"))
        def get_raw(self):
            a = self.npts[0]
            b = self.npts[1]
            c = self.npts[2]
            return np.reshape(np.arange(a*b*c), (a, b, c))
        
    # a string-valued parameter
    def dac1_too_high():
        return 'Too high' if dac.ch1() > 5 else 'OK'

.. code:: ipython3

    dac.add_parameter('control', get_cmd=dac1_too_high)
    SA.add_parameter('spectrum', parameter_class=Spectrum)
    SA.add_parameter('spectrum3D', parameter_class=MultiDimSpectrum)

Numeric
-------

The ``numeric`` datatype is simply a number. Data registered with this
type are saved as individual numbers. This is the **default** datatype
when registering parameters.

Numeric example 1
~~~~~~~~~~~~~~~~~

In this example, all parameters get registered as ``numeric`` type. This
entails that the array in unraveled and inserted point-by-point.

.. code:: ipython3

    meas = Measurement()
    meas.register_parameter(dac.ch1)
    meas.register_parameter(SA.spectrum, setpoints=(dac.ch1,))
    
    t0 = time.perf_counter()
    
    with meas.run() as datasaver:
        for dac_v in np.linspace(0, 2, 5):
            dac.ch1(dac_v)
            datasaver.add_result((dac.ch1, dac_v), (SA.spectrum, SA.spectrum()))
    
    t1 = time.perf_counter()
    
    print(f'Finished run in {(t1-t0):.3f} s')
            
    run_id1 = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 1
    Finished run in 0.043 s


The data may be retrieved using ``get_data_by_id``. This function will
always bring back the data **as if** it had been stored in a
point-by-point format. That is to say, all parameters come out as array
of the same length, with setpoints values appropriately repeated.

.. code:: ipython3

    get_data_by_id(run_id1)




.. parsed-literal::

    [[{'name': 'dac_ch1',
       'label': 'Gate ch1',
       'unit': 'V',
       'data': array([ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0.5,  0.5,  0.5,  0.5,
               0.5,  0.5,  0.5,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1.5,
               1.5,  1.5,  1.5,  1.5,  1.5,  1.5,  2. ,  2. ,  2. ,  2. ,  2. ,
               2. ,  2. ])},
      {'name': 'SA_Frequency',
       'label': '',
       'unit': 'Hz',
       'data': array([ 0.        ,  0.16666667,  0.33333333,  0.5       ,  0.66666667,
               0.83333333,  1.        ,  0.        ,  0.16666667,  0.33333333,
               0.5       ,  0.66666667,  0.83333333,  1.        ,  0.        ,
               0.16666667,  0.33333333,  0.5       ,  0.66666667,  0.83333333,
               1.        ,  0.        ,  0.16666667,  0.33333333,  0.5       ,
               0.66666667,  0.83333333,  1.        ,  0.        ,  0.16666667,
               0.33333333,  0.5       ,  0.66666667,  0.83333333,  1.        ])},
      {'name': 'SA_spectrum',
       'label': 'Noisy spectrum',
       'unit': 'V/sqrt(Hz)',
       'data': array([-0.41575318,  0.67521971, -0.88198899, -1.03425626, -0.01854334,
               0.44361874, -0.42334945,  0.26189276,  1.00766109, -0.52297405,
               0.63651024,  0.30704751,  0.81955757,  0.492617  , -1.99379593,
               0.75687734, -0.14385515, -1.74240484,  0.38675237, -0.81998126,
              -0.57524366,  0.50792126,  1.32704778,  1.76717421,  0.17032677,
              -0.73232403,  0.21313064,  1.8994602 ,  0.41199585,  0.58305243,
              -1.64661294,  1.03831814, -0.3344649 ,  0.84612123, -0.72703733])}]]



Array
-----

The array paramtype stores data as binary blobs in the database.
Insertion is faster (asymptotically **much** faster) this way, but the
data are "dead" to SQL queries inside the database.

Array example 1
~~~~~~~~~~~~~~~

Let us repeat the above measurement, but this time using ``array``
paramtypes.

.. code:: ipython3

    meas = Measurement()
    meas.register_parameter(dac.ch1)
    meas.register_parameter(SA.spectrum, setpoints=(dac.ch1,), paramtype='array')
    
    t0 = time.perf_counter()
    
    with meas.run() as datasaver:
        for dac_v in np.linspace(0, 2, 5):
            dac.ch1(dac_v)
            datasaver.add_result((dac.ch1, dac_v), (SA.spectrum, SA.spectrum()))
    
    t1 = time.perf_counter()
    
    print(f'Finished run in {(t1-t0):.3f} s')
            
    run_id2 = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 2
    Finished run in 0.043 s


Reading back out the data, we can **not** see whether they were stored
as ``numeric`` or ``array`` type.

.. code:: ipython3

    get_data_by_id(run_id2)




.. parsed-literal::

    [[{'name': 'dac_ch1',
       'label': 'Gate ch1',
       'unit': 'V',
       'data': array([ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0.5,  0.5,  0.5,  0.5,
               0.5,  0.5,  0.5,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1. ,  1.5,
               1.5,  1.5,  1.5,  1.5,  1.5,  1.5,  2. ,  2. ,  2. ,  2. ,  2. ,
               2. ,  2. ])},
      {'name': 'SA_Frequency',
       'label': '',
       'unit': 'Hz',
       'data': array([ 0.        ,  0.16666667,  0.33333333,  0.5       ,  0.66666667,
               0.83333333,  1.        ,  0.        ,  0.16666667,  0.33333333,
               0.5       ,  0.66666667,  0.83333333,  1.        ,  0.        ,
               0.16666667,  0.33333333,  0.5       ,  0.66666667,  0.83333333,
               1.        ,  0.        ,  0.16666667,  0.33333333,  0.5       ,
               0.66666667,  0.83333333,  1.        ,  0.        ,  0.16666667,
               0.33333333,  0.5       ,  0.66666667,  0.83333333,  1.        ])},
      {'name': 'SA_spectrum',
       'label': 'Noisy spectrum',
       'unit': 'V/sqrt(Hz)',
       'data': array([  5.55129261e-01,  -1.07365225e+00,  -4.87608061e-01,
               -2.70251481e-01,   7.83190409e-01,   3.12159230e-01,
                4.23249160e-01,  -2.69308493e-03,   1.64535471e-01,
                9.73299700e-01,   1.77585593e-01,  -1.70805993e+00,
                1.20598748e+00,  -1.34892259e+00,  -1.24125037e+00,
                1.61473668e+00,   5.73625104e-01,  -1.62599665e+00,
               -3.50047533e-01,   1.68704828e+00,  -1.94490514e+00,
               -8.32452127e-01,  -2.85168342e+00,  -5.23240042e-01,
                1.94966791e-01,  -5.95185689e-01,   6.95388071e-01,
               -1.55005579e+00,   1.23369993e-01,   1.27478193e+00,
                3.82239666e-01,   6.44777215e-01,  -2.75844288e-01,
               -1.52168909e+00,  -2.46380532e-01])}]]



Array example 2
~~~~~~~~~~~~~~~

When storing multidimensional array data (think: Alazar cards), both
``numeric`` and ``array`` type can be used.

.. code:: ipython3

    meas = Measurement()
    meas.register_parameter(SA.spectrum3D, paramtype='array')
    
    with meas.run() as datasaver:
        datasaver.add_result((SA.spectrum3D, SA.spectrum3D()))
    run_id3 = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 3


The data come out the way we expect them to.

.. code:: ipython3

    get_data_by_id(run_id3)




.. parsed-literal::

    [[{'name': 'SA_Frequency0',
       'label': '',
       'unit': 'Hz',
       'data': array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,
               0.,  0.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,
               1.,  1.,  1.,  1.])},
      {'name': 'SA_Frequency1',
       'label': '',
       'unit': 'Other Hz',
       'data': array([ 0.  ,  0.  ,  0.  ,  0.25,  0.25,  0.25,  0.5 ,  0.5 ,  0.5 ,
               0.75,  0.75,  0.75,  1.  ,  1.  ,  1.  ,  0.  ,  0.  ,  0.  ,
               0.25,  0.25,  0.25,  0.5 ,  0.5 ,  0.5 ,  0.75,  0.75,  0.75,
               1.  ,  1.  ,  1.  ])},
      {'name': 'SA_Frequency2',
       'label': '',
       'unit': 'Third Hz',
       'data': array([ 0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,
               1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,
               0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ])},
      {'name': 'SA_spectrum3D',
       'label': 'Flower Power Spectrum in 3D',
       'unit': 'V/sqrt(Hz)',
       'data': array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
              17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])}]]



Array example 3
~~~~~~~~~~~~~~~

For completeness, an example where the multidimensional array has an
auxiliary setpoint.

.. code:: ipython3

    meas = Measurement()
    meas.register_parameter(dac.ch1)
    meas.register_parameter(SA.spectrum3D, paramtype='array', setpoints=(dac.ch1,))
    
    with meas.run() as datasaver:
        for dac_v in [3, 4, 5]:
            dac.ch1(dac_v)
            datasaver.add_result((dac.ch1, dac_v),
                                 (SA.spectrum3D, SA.spectrum3D()))
    run_id4 = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 4


.. code:: ipython3

    get_data_by_id(run_id4)




.. parsed-literal::

    [[{'name': 'dac_ch1',
       'label': 'Gate ch1',
       'unit': 'V',
       'data': array([3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
              3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
              4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5])},
      {'name': 'SA_Frequency0',
       'label': '',
       'unit': 'Hz',
       'data': array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,
               0.,  0.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,
               1.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,
               0.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,
               1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.,
               0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  1.,  1.,  1.,
               1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])},
      {'name': 'SA_Frequency1',
       'label': '',
       'unit': 'Other Hz',
       'data': array([ 0.  ,  0.  ,  0.  ,  0.25,  0.25,  0.25,  0.5 ,  0.5 ,  0.5 ,
               0.75,  0.75,  0.75,  1.  ,  1.  ,  1.  ,  0.  ,  0.  ,  0.  ,
               0.25,  0.25,  0.25,  0.5 ,  0.5 ,  0.5 ,  0.75,  0.75,  0.75,
               1.  ,  1.  ,  1.  ,  0.  ,  0.  ,  0.  ,  0.25,  0.25,  0.25,
               0.5 ,  0.5 ,  0.5 ,  0.75,  0.75,  0.75,  1.  ,  1.  ,  1.  ,
               0.  ,  0.  ,  0.  ,  0.25,  0.25,  0.25,  0.5 ,  0.5 ,  0.5 ,
               0.75,  0.75,  0.75,  1.  ,  1.  ,  1.  ,  0.  ,  0.  ,  0.  ,
               0.25,  0.25,  0.25,  0.5 ,  0.5 ,  0.5 ,  0.75,  0.75,  0.75,
               1.  ,  1.  ,  1.  ,  0.  ,  0.  ,  0.  ,  0.25,  0.25,  0.25,
               0.5 ,  0.5 ,  0.5 ,  0.75,  0.75,  0.75,  1.  ,  1.  ,  1.  ])},
      {'name': 'SA_Frequency2',
       'label': '',
       'unit': 'Third Hz',
       'data': array([ 0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,
               1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,
               0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,
               0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,
               1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,
               0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,
               0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,
               1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,  0.5,  1. ,  0. ,
               0.5,  1. ])},
      {'name': 'SA_spectrum3D',
       'label': 'Flower Power Spectrum in 3D',
       'unit': 'V/sqrt(Hz)',
       'data': array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
              17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,  0,  1,  2,  3,
               4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
              21, 22, 23, 24, 25, 26, 27, 28, 29,  0,  1,  2,  3,  4,  5,  6,  7,
               8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
              25, 26, 27, 28, 29])}]]



Text
----

Text is strings. Sometimes it may be useful to capture a log message or
similar.

.. code:: ipython3

    meas = Measurement()
    meas.register_parameter(dac.ch1)
    meas.register_parameter(dac.control, setpoints=(dac.ch1,), paramtype='text')
    
    with meas.run() as datasaver:
        for dac_v in np.linspace(4, 6, 10):
            dac.ch1(dac_v)
            datasaver.add_result((dac.ch1, dac_v),
                                 (dac.control, dac.control()))
    run_id5 = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 5


.. code:: ipython3

    get_data_by_id(run_id5)




.. parsed-literal::

    [[{'name': 'dac_ch1',
       'label': 'Gate ch1',
       'unit': 'V',
       'data': array([ 4.        ,  4.22222222,  4.44444444,  4.66666667,  4.88888889,
               5.11111111,  5.33333333,  5.55555556,  5.77777778,  6.        ])},
      {'name': 'dac_control',
       'label': 'control',
       'unit': '',
       'data': array(['OK', 'OK', 'OK', 'OK', 'OK', 'Too high', 'Too high', 'Too high',
              'Too high', 'Too high'],
             dtype='<U8')}]]



