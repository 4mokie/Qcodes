
The Context Manager aka the Measurement Object
==============================================

This notebook shows some ways of performing different measurements using
QCoDeS parameters and the new DataSet accessed via a context manager.

.. code:: ipython3

    %matplotlib notebook
    from collections import OrderedDict
    from typing import Dict, Callable
    from inspect import signature
    import numpy.random as rd
    import matplotlib.pyplot as plt
    import json
    from functools import partial
    import numpy as np
    
    from time import sleep, monotonic
    
    import qcodes as qc
    from qcodes import Station
    from qcodes.dataset.experiment_container import (Experiment,
                                                     load_last_experiment,
                                                     new_experiment)
    from qcodes.dataset.database import initialise_database
    from qcodes.tests.instrument_mocks import DummyInstrument
    from qcodes.dataset.param_spec import ParamSpec
    from qcodes.dataset.measurements import Measurement
    from qcodes.dataset.plotting import plot_by_id
    from qcodes.dataset.data_export import get_shaped_data_by_runid
    
    # import logging
    # logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')


.. code:: ipython3

    # a generator to simulate a physical signal, in this case an exponentially
    # decaying signal
    
    def exponential_decay(a: float, b: float):
        """
        Yields a*exp(-b*x) where x is put in 
        """
        x = 0
        while True:
            x = yield
            yield a*np.exp(-b*x) + 0.02*a*np.random.randn()

.. code:: ipython3

    # preparatory mocking of physical setup
    
    dac = DummyInstrument('dac', gates=['ch1', 'ch2'])
    dmm = DummyInstrument('dmm', gates=['v1', 'v2'])
    
    station = qc.Station(dmm, dac)

.. code:: ipython3

    # and then a bit of "wiring" to make the dmm "measure"
    # the exponential decay
    
    ed = exponential_decay(5, 0.2)
    next(ed)
    
    def customgetter(dac):
        val = ed.send(dac.ch1())
        next(ed)
        return val
        
    dmm.v1.get = partial(customgetter, dac)

.. code:: ipython3

    # now make some silly set-up and tear-down actions
    
    def veryfirst():
        print('Starting the measurement')
    
    def numbertwo(inst1, inst2):
        print('Doing stuff with the following two instruments: {}, {}'.format(inst1, inst2))
        
    def thelast():
        print('End of experiment')

NB: database and experiments may be missing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If this is the first time you create a dataset, the underlying database
file has most likely not been created. The following cell creates the
database file. Please refer to documentation on
``The Experiment Container`` for details.

Furthermore, datasets are appended to existing experiments. If no
experiment has been created, we must create one.

.. code:: ipython3

    initialise_database()
    new_experiment(name='tutorial_exp', sample_name="no sample")




.. parsed-literal::

    tutorial_exp#no sample#2@./exp_container_tutorial.db
    ----------------------------------------------------



.. code:: ipython3

    # And then run an experiment
    
    meas = Measurement()
    meas.register_parameter(dac.ch1)  # register the first independent parameter
    meas.register_parameter(dmm.v1, setpoints=(dac.ch1,))  # now register the dependent oone
    meas.add_before_run(veryfirst, ())  # add a set-up action
    meas.add_before_run(numbertwo, (dmm, dac))  # add another set-up action
    meas.add_after_run(thelast, ())  # add a tear-down action
    
    meas.write_period = 2
    
    
    with meas.run() as datasaver:
                 
        for set_v in np.linspace(0, 25, 10):
            dac.ch1.set(set_v)
            get_v = dmm.v1.get()
            datasaver.add_result((dac.ch1, set_v),
                                 (dmm.v1, get_v))
        
        dataid = datasaver.run_id  # convenient to have for plotting



.. parsed-literal::

    Starting the measurement
    Doing stuff with the following two instruments: <DummyInstrument: dmm>, <DummyInstrument: dac>
    Starting experimental run with id: 8
    End of experiment


.. code:: ipython3

    ax, cbax = plot_by_id(dataid)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='e16fb280-996d-4387-b142-ea5c6a5e2e3e'></div>


The power of the new construct
------------------------------

This new form is so free that we may easily do thing impossible with the
old Loop construct

.. code:: ipython3

    # from the above plot, we decide that a voltage below 
    # 1 V is uninteresting, so we stop the sweep at that point
    # thus, we do not know in advance how many points we'll measure
    
    with meas.run() as datasaver:
            
        for set_v in np.linspace(0, 25, 100):
            dac.ch1.set(set_v)
            get_v = dmm.v1.get()        
            datasaver.add_result((dac.ch1, set_v),
                                 (dmm.v1, get_v))
    
            if get_v < 1:
                break
            
        
        dataid = datasaver.run_id  # convenient to have for plotting


.. parsed-literal::

    Starting the measurement
    Doing stuff with the following two instruments: <DummyInstrument: dmm>, <DummyInstrument: dac>
    Starting experimental run with id: 9
    End of experiment


.. code:: ipython3

    ax, cbax = plot_by_id(dataid)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='08ac2842-e901-49ad-bda8-c7913f030c80'></div>


.. code:: ipython3

    # Or we might want to simply get as many points as possible in 10 s
    # randomly sampling the region between 0 V and 10 V (for the setpoint axis)
    
    from time import monotonic, sleep
    
    with meas.run() as datasaver:
        
        t_start = monotonic()
        
        while monotonic() - t_start < 10:
            set_v = 10/2*(np.random.rand() + 1)
            dac.ch1.set(set_v)
            
            # some sleep to not get too many points (or to let the system settle)
            sleep(0.1)
            
            get_v = dmm.v1.get()        
            datasaver.add_result((dac.ch1, set_v),
                                 (dmm.v1, get_v))
        
        dataid = datasaver.run_id  # convenient to have for plotting


.. parsed-literal::

    Starting the measurement
    Doing stuff with the following two instruments: <DummyInstrument: dmm>, <DummyInstrument: dac>
    Starting experimental run with id: 10
    End of experiment


.. code:: ipython3

    axes, cbaxes = plot_by_id(dataid)
    # we slightly tweak the plot to better visualise the highly non-standard axis spacing
    axes[0].lines[0].set_marker('o')
    axes[0].lines[0].set_markerfacecolor((0.6, 0.6, 0.9))
    axes[0].lines[0].set_markeredgecolor((0.4, 0.6, 0.9))
    axes[0].lines[0].set_color((0.8, 0.8, 0.8))



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='4b6e1c2e-58b2-44bd-b557-4cd8a0b00dd4'></div>


Some 2D examples
----------------

.. code:: ipython3

    # For the 2D, we'll need a new batch of parameters, notably one with two 
    # other parameters as setpoints. We therefore define a new Measurement
    # with new parameters
    
    meas = Measurement()
    meas.register_parameter(dac.ch1)  # register the first independent parameter
    meas.register_parameter(dac.ch2)  # register the second independent parameter
    meas.register_parameter(dmm.v1, setpoints=(dac.ch1, dac.ch2))  # now register the dependent oone

.. code:: ipython3

    # and we'll make a 2D gaussian to sample from/measure
    def gauss_model(x0: float, y0: float, sigma: float, noise: float=0.0005):
        """
        Returns a generator sampling a gaussian. The gaussian is
        normalised such that its maximal value is simply 1
        """
        while True:
            (x, y) = yield
            model = np.exp(-((x0-x)**2+(y0-y)**2)/2/sigma**2)*np.exp(2*sigma**2)
            noise = np.random.randn()*noise
            yield model + noise

.. code:: ipython3

    # and finally wire up the dmm v1 to "measure" the gaussian
    
    gauss = gauss_model(0.1, 0.2, 0.25)
    next(gauss)
    
    def measure_gauss(dac):
        val = gauss.send((dac.ch1.get(), dac.ch2.get()))
        next(gauss)
        return val
    
    dmm.v1.get = partial(measure_gauss, dac)

.. code:: ipython3

    # run a 2D sweep
    
    with meas.run() as datasaver:
    
        for v1 in np.linspace(-1, 1, 200):
            for v2 in np.linspace(-1, 1, 200):
                dac.ch1(v1)
                dac.ch2(v2)
                val = dmm.v1.get()
                datasaver.add_result((dac.ch1, v1),
                                     (dac.ch2, v2),
                                     (dmm.v1, val))
                
        dataid = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 11


.. code:: ipython3

    ax, abax = plot_by_id(dataid)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='43c43489-66bc-4459-82b1-99f9d9bd7ded'></div>


.. code:: ipython3

    # Looking at the above picture, we may decide to sample more finely in the central
    # region
    
    with meas.run() as datasaver:
    
        v1points = np.concatenate((np.linspace(-1, -0.5, 5),
                                   np.linspace(-0.51, 0.5, 200),
                                   np.linspace(0.51, 1, 5)))
        v2points = np.concatenate((np.linspace(-1, -0.25, 5),
                                   np.linspace(-0.26, 0.5, 200),
                                   np.linspace(0.51, 1, 5)))
        
        for v1 in v1points:
            for v2 in v2points:
                dac.ch1(v1)
                dac.ch2(v2)
                val = dmm.v1.get()
                datasaver.add_result((dac.ch1, v1),
                                     (dac.ch2, v2),
                                     (dmm.v1, val))
    
        dataid = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 12


.. code:: ipython3

    ax, cbax = plot_by_id(dataid)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='455354c1-8bcb-465e-81eb-01ec9e357752'></div>


.. code:: ipython3

    # or even perform an adaptive sweep... ooohh...
    #
    # This example is a not-very-clever toy model example,
    # but it nicely shows a semi-realistic measurement that the old qc.Loop
    # could not handle
    
    v1_points = np.linspace(-1, 1, 250)
    v2_points = np.linspace(1, -1, 250)
    
    threshold = 0.25
    
    with meas.run() as datasaver:
        
        # Do normal sweeping until the peak is detected
        
        for v2ind, v2 in enumerate(v2_points):
            for v1ind, v1 in enumerate(v1_points):
                dac.ch1(v1)
                dac.ch2(v2)
                val = dmm.v1.get()
                datasaver.add_result((dac.ch1, v1),
                                     (dac.ch2, v2),
                                     (dmm.v1, val))
                if val > threshold:
                    break
            else:
                continue
            break
            
        print(v1ind, v2ind, val)
        print('-'*10)
            
        # now be more clever, meandering back and forth over the peak
        doneyet = False
        rowdone = False
        v1_step = 1
        while not doneyet:
                v2 = v2_points[v2ind]
                v1 = v1_points[v1ind+v1_step-1]
                dac.ch1(v1)
                dac.ch2(v2)
                val = dmm.v1.get()
                datasaver.add_result((dac.ch1, v1),
                                     (dac.ch2, v2),
                                     (dmm.v1, val))
                if val < threshold:
                    if rowdone:
                        doneyet = True
                    v2ind += 1
                    v1_step *= -1
                    rowdone = True
                else:
                    v1ind += v1_step
                    rowdone = False
                    
    dataid = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 13
    130 46 0.25089416831
    ----------


.. code:: ipython3

    ax, cbax = plot_by_id(dataid)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='f009d922-a243-426e-87d1-da03238efc67'></div>


Random sampling
---------------

We may also chose to sample completly randomly across the phase space

.. code:: ipython3

    gauss = gauss_model(0.1, 0.2, 0.25)
    next(gauss)
    
    def measure_gauss(x, y):
        val = gauss.send((x, y))
        next(gauss)
        return val
    


.. code:: ipython3

    v1_points = np.linspace(-1, 1, 250)
    v2_points = np.linspace(1, -1, 250)
    
    threshold = 0.25
    
    npoints = 5000
    
    with meas.run() as datasaver:
        for i in range(npoints):
            x = 2*(np.random.rand()-.5)
            y = 2*(np.random.rand()-.5)
            z = measure_gauss(x,y)
            datasaver.add_result((dac.ch1, x),
                         (dac.ch2, y),
                         (dmm.v1, z))
    dataid = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 14


.. code:: ipython3

    ax, cbax = plot_by_id(dataid)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='2b9fdc41-c769-417f-b0de-4cc9b1a3407e'></div>


Optimiser
---------

An example to show that the algorithm is flexible enough to be used with
completly unstructured data such as the output of an downhill simplex
optimization. The downhill simplex is somewhat more sensitive to noise
and it is important that 'fatol' is set to match the expected noise.

.. code:: ipython3

    from scipy.optimize import minimize

.. code:: ipython3

    noise = 0.0005
    
    gauss = gauss_model(0.1, 0.2, 0.25, noise=noise)
    next(gauss)
    
    def measure_gauss(x, y):
        val = gauss.send((x, y))
        next(gauss)
        return val


.. code:: ipython3

    x0 = [np.random.rand(), np.random.rand()]
    with meas.run() as datasaver:
        def mycallback(xk):
            datasaver.add_result((dac.ch1, xk[0]),
                         (dac.ch2, xk[1]),
                         (dmm.v1, measure_gauss(xk[0], xk[1])))
        
        res = minimize(lambda x: -measure_gauss(*x), x0, method='Nelder-Mead', tol=1e-10, 
                       callback=mycallback, options={'fatol': noise})
        
        run_id = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 15


.. code:: ipython3

    res




.. parsed-literal::

     final_simplex: (array([[ 0.1,  0.2],
           [ 0.1,  0.2],
           [ 0.1,  0.2]]), array([-1.13314845, -1.13314845, -1.13314845]))
               fun: -1.1331484530668263
           message: 'Optimization terminated successfully.'
              nfev: 174
               nit: 85
            status: 0
           success: True
                 x: array([ 0.1,  0.2])



.. code:: ipython3

    ax, cbax = plot_by_id(run_id)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='96d7862a-d86c-43e8-bd9a-e9a9fe8766fe'></div>


Subscriptions
-------------

The Measurement object can also handle subscriptions to the dataset.
Subscriptions are really, under the hood, triggers in the underlying
SQLite database. Therefore, the subscribers are only called when data is
written to the database (which happens every ``write_period``).

When making a subscription, two things must be supplied, a function and
a mutable state object. The function **MUST** have a call signature of
``f(result_list, length, state, **kwargs)``, where result\_list is a
list of tuples of parameter values inserted in the dataset, length is an
integer (the step number of the run), and state is the mutable state
object. The function does not need to actually use these arguments, but
the call signature must match this.

We show two examples of subscribtions here.

Subscription example 1: simple printing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: ipython3

    
    
    def print_which_step(results_list, length, state):
        """
        This subscriber does not use results_list nor state; it simply
        prints how many results we have added to the database
        """
        print(f'The run now holds {length} rows')
        
        
    meas = Measurement()
    meas.register_parameter(dac.ch1)
    meas.register_parameter(dmm.v1, setpoints=(dac.ch1,))
    
    meas.write_period = 1  # We write to the database every 1 second
    
    meas.add_subscriber(print_which_step, state=[])
    
    with meas.run() as datasaver:
        for n in range(10):
            datasaver.add_result((dac.ch1, n), (dmm.v1, n**2))
            print(f'Added points to measurement, step {n}.')
            sleep(0.5)


.. parsed-literal::

    Starting experimental run with id: 16
    Added points to measurement, step 0.
    Added points to measurement, step 1.
    The run now holds 3 rows
    Added points to measurement, step 2.
    Added points to measurement, step 3.
    The run now holds 5 rows
    Added points to measurement, step 4.
    Added points to measurement, step 5.
    The run now holds 7 rows
    Added points to measurement, step 6.
    Added points to measurement, step 7.
    The run now holds 9 rows
    Added points to measurement, step 8.
    Added points to measurement, step 9.
    The run now holds 10 rows
    The run now holds 10 rows
    The run now holds 10 rows


Subscription example 2: using the state
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We add two subscribers now.

.. code:: ipython3

    
    
    def get_list_of_first_param(results_list, lenght, state):
        """
        Modify the state (a list) to hold all the values for
        the first parameter
        """
        param_vals = [parvals[0] for parvals in results_list]
        state += param_vals
        
    meas = Measurement()
    meas.register_parameter(dac.ch1)
    meas.register_parameter(dmm.v1, setpoints=(dac.ch1,))
    
    meas.write_period = 1  # We write to the database every 1 second
    
    first_param_list = []
    
    meas.add_subscriber(print_which_step, state=[])
    meas.add_subscriber(get_list_of_first_param, state=first_param_list)
    
    with meas.run() as datasaver:
        for n in range(10):
            datasaver.add_result((dac.ch1, n), (dmm.v1, n**2))
            print(f'Added points to measurement, step {n}.')
            print(f'First parameter value list: {first_param_list}')
            sleep(0.5)


.. parsed-literal::

    Starting experimental run with id: 17
    Added points to measurement, step 0.
    First parameter value list: []
    Added points to measurement, step 1.
    First parameter value list: []
    The run now holds 3 rows
    Added points to measurement, step 2.
    First parameter value list: [0, 1, 2]
    Added points to measurement, step 3.
    First parameter value list: [0, 1, 2]
    The run now holds 5 rows
    Added points to measurement, step 4.
    First parameter value list: [0, 1, 2, 3, 4]
    Added points to measurement, step 5.
    First parameter value list: [0, 1, 2, 3, 4]
    The run now holds 7 rows
    Added points to measurement, step 6.
    First parameter value list: [0, 1, 2, 3, 4, 5, 6]
    Added points to measurement, step 7.
    First parameter value list: [0, 1, 2, 3, 4, 5, 6]
    The run now holds 9 rows
    Added points to measurement, step 8.
    First parameter value list: [0, 1, 2, 3, 4, 5, 6, 7, 8]
    Added points to measurement, step 9.
    First parameter value list: [0, 1, 2, 3, 4, 5, 6, 7, 8]
    The run now holds 10 rows
    The run now holds 10 rows
    The run now holds 10 rows

