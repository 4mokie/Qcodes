
Offline Plotting Tutorial
=========================

The dataset comes with a tool for offline (i.e. not live as the data are
coming in) plotting. This notebook explains how to use it and what it is
capable of plotting.

The tool in question is the function ``plot_by_id``.

.. code:: ipython3

    %matplotlib notebook
    import numpy as np
    
    import qcodes as qc
    
    from typing import List, Dict, Tuple, Any
    import matplotlib.pyplot as plt
    import qcodes as qc
    from qcodes import Parameter, new_experiment, Measurement
    from qcodes.dataset.plotting import plot_by_id
    from qcodes.dataset.database import initialise_database

First we make an experimental run, so that we have something to plot.

.. code:: ipython3

    initialise_database()
    new_experiment('test_plot_by_id', 'nosample')




.. parsed-literal::

    test_plot_by_id#nosample#1@./exp_container_tutorial.db
    ------------------------------------------------------



Next we make a handful of parameters to be used in the examples of this
notebook.

For those curious, setting ``set_cmd=None`` and ``get_cmd=None`` makes
the ``Parameters`` settable and gettable without them being hooked up to
any external/auxiliary action (in old QCoDeS versions, this was known as
a ``ManualParameter``).

.. code:: ipython3

    # Make a handful of parameters to be used in the examples
    
    x = Parameter(name='x', label='Voltage', unit='V',
                  set_cmd=None, get_cmd=None)
    t = Parameter(name='t', label='Time', unit='s',
                  set_cmd=None, get_cmd=None)
    y = Parameter(name='y', label='Voltage', unit='V',
                  set_cmd=None, get_cmd=None)
    y2 = Parameter(name='y2', label='Current', unit='A',
                   set_cmd=None, get_cmd=None)
    z = Parameter(name='z', label='Majorana number', unit='Anyonic charge',
                  set_cmd=None, get_cmd=None)

A single, simple 1D sweep
-------------------------

.. code:: ipython3

    meas = Measurement()
    meas.register_parameter(x)
    meas.register_parameter(y, setpoints=(x,))
    
    xvals = np.linspace(-3.4, 4.2, 250)
    
    # shuffle randomly the values in order to test that plot
    # that is to be created for this data is a correct line
    # that does not depend on the order of the data
    np.random.shuffle(xvals)
    
    with meas.run() as datasaver:
        for xnum in xvals:
            noise = np.random.randn()*0.1  # multiplicative noise yeah yeah
            datasaver.add_result((x, xnum),
                                 (y, 2*(xnum+noise)**3 - 5*(xnum+noise)**2))
    
    dataid = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 1


Now let us plot that run. The function ``plot_by_id`` takes the
``run_id`` of the run to plot as a positional argument. Furthermore, the
user may specify the matplotlib axis object (or list of axis objects) to
plot on.

If no axes are specified, the function creates new axis object(s). The
function returns a tuple of a list of the axes and a list of the
colorbar axes (just ``None``\ s if there are no colorbars).

.. code:: ipython3

    axes, cbaxes = plot_by_id(dataid)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='ea135677-c901-40b0-bb5d-be244145d1ee'></div>


Using the returned axis, we can e.g. change the plot linewidth and
color. We refer to the matplotlib documentation for details on
matplotlib plot customization.

.. code:: ipython3

    my_ax = axes[0]
    line = my_ax.lines[0]
    line.set_color('#223344')
    line.set_linewidth(3)

Rescaling units and ticks
~~~~~~~~~~~~~~~~~~~~~~~~~

``plot_by_id`` can conveniently rescale the units and ticks of the plot.
For example, if one of the axes is voltage in units of ``V``, but the
values are in the range of millivolts, then ``plot_by_id`` will rescale
the ticks of the axis to show ``5`` instead of ``0.005``, and the unit
in the axis label will be adjusted from ``V`` to ``mV``.

This feature works with the relevant SI units, and some others. In case
the units of the parameter are not from that list, or are simply not
specified, ticks and labels are left intact.

The feature can be explicitly turned off by passing
``rescale_axes=False`` to ``plot_by_id``.

The following plot demontrates the feature.

.. code:: ipython3

    meas = Measurement()
    meas.register_parameter(t)
    meas.register_parameter(y, setpoints=(t,))
    
    with meas.run() as datasaver:
        for tnum in np.linspace(-3.4, 4.2, 50):
            noise = np.random.randn()*0.1
            datasaver.add_result((t, tnum*1e-6),
                                 (y, (2*(tnum+noise)**3 - 5*(tnum+noise)**2)*1e3))
    
    dataid = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 2


.. code:: ipython3

    plot_by_id(dataid)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='0d00f5dd-87a7-4884-854c-0ea81374ad13'></div>




.. parsed-literal::

    ([<matplotlib.axes._subplots.AxesSubplot at 0x7f0093f4dcc0>], [None])



Two interleaved 1D sweeps
-------------------------

Now we make a run where two parameters are measured as a function of the
same parameter.

.. code:: ipython3

    meas = Measurement()
    meas.register_parameter(x)
    meas.register_parameter(y, setpoints=[x])
    meas.register_parameter(y2, setpoints=[x])
    
    xvals = np.linspace(-5, 5, 250)
    
    with meas.run() as datasaver:
    
        for xnum in xvals:
            datasaver.add_result((x, xnum),
                                 (y, xnum**2))
            datasaver.add_result((x, xnum),
                                 (y2, -xnum**2))
    
    dataid = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 3


In such a situation, ``plot_by_id`` by default creates a new axis for
**each** dependent parameter. Sometimes this is not desirable; we'd
rather have both plots on the same axis. In such a case, we might pass
the same axis twice to ``plot_by_id``.

.. code:: ipython3

    axes, cbaxes = plot_by_id(dataid)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='9ea11091-c1a0-40be-998d-a4849aba28f0'></div>



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='83ae5c9c-3a47-4db9-8f68-b3c3bfd367a3'></div>


Let's do that now

.. code:: ipython3

    fig, ax = plt.subplots(1)
    axes, cbaxes = plot_by_id(dataid, axes=[ax, ax])



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='992526de-2114-4b02-a610-c6f20fd19bdd'></div>


Regular 2D rectangular sweep scan
---------------------------------

For 2D plots, a colorbar is usually present. As mentioned above,
``plot_by_id`` returns this.

.. code:: ipython3

    meas = Measurement()
    
    meas.register_parameter(x)
    meas.register_parameter(t)
    meas.register_parameter(z, setpoints=(x, t))
    
    xvals = np.linspace(-4, 5, 50)
    tvals = np.linspace(-500, 1500, 25)
    
    with meas.run() as datasaver:
        for xv in xvals:
            for tv in tvals:
                # just some arbitrary semi good looking function
                zv = np.sin(2*np.pi*xv)*np.cos(2*np.pi*0.001*tv) + 0.001*tv
                datasaver.add_result((x, xv), (t, tv), (z, zv))
    
    dataid = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 4


.. code:: ipython3

    axes, colorbars = plot_by_id(dataid)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='35e22bb7-b725-4291-95d3-d43bf5e08eb9'></div>


A fairlt normal situation is that the colorbar was somehow mislabelled.
Using the returned colorbar, the label can be overwritten.

.. code:: ipython3

    colorbar = colorbars[0]
    colorbar.set_label('Correct science label')

Warped 2D rectangular sweep scan
--------------------------------

A nice feature of ``plot_by_id`` is that the grid may be warped; it
makes no difference. Here we warp the x axis of the previous scan to
increase the resolution in the right half plane.

.. code:: ipython3

    xvals = np.linspace(-4, 5, 50) + np.cos(-1/6*np.pi*xvals)
    tvals = np.linspace(-500, 1500, 25)
    
    with meas.run() as datasaver:
        for xv in xvals:
            for tv in tvals:
                zv = np.sin(2*np.pi*xv)*np.cos(2*np.pi*0.001*tv) + 0.001*tv
                datasaver.add_result((x, xv), (t, tv), (z, zv))
    
    dataid = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 5


.. code:: ipython3

    axes, cbaxes = plot_by_id(dataid)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='18391344-810c-4bac-8582-20c4633d8cd6'></div>


Interrupted 2D scans (a hole in the cheese)
-------------------------------------------

In case a sweep in interrupted, the entire grid will not be filled out.
This is also supported, in fact, any single rectangular hole is allowed

.. code:: ipython3

    xvals = np.linspace(-4, 5, 50) + np.cos(2/9*np.pi*xvals+np.pi/4)
    tvals = np.linspace(-500, 1500, 25)
    
    # define two small forbidden range functions
    def no_x(xv):
        if xv > 0 and xv < 3:
            return True
        else:
            return False
        
    def no_t(tv):
        if tv > 0 and tv < 450:
            return True
        else:
            return False
    
    with meas.run() as datasaver:
        for xv in xvals:
            for tv in tvals:
                if no_x(xv) and no_t(tv):
                    continue
                else:
                    zv = np.sin(2*np.pi*xv)*np.cos(2*np.pi*0.001*tv) + 0.001*tv
                    datasaver.add_result((x, xv), (t, tv), (z, zv))
    
    dataid = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 6


.. code:: ipython3

    axes, colorbars = plot_by_id(dataid)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='2e90dcfd-429c-47da-a211-552a892c7d8a'></div>


Plots with string (categorial) data
-----------------------------------

``plot_by_id`` supports plotting categorial data (strings) as well. The
tick labels of the plots contain the string values.

Note that this feature requires ``matplotlib`` version ``2.1`` (or
newer).

1D cases
~~~~~~~~

String-valued indepentent parameter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's use an example of a qubit measurement. These measurements are
quite complicated, but for the sake of this example we will abstract
away from all the complexity, and simulate the values of the relevant
parameters.

In this example, the string-valued parameter is independent.

**NOTE**: for string-valued parameters, one must specify
``paramtype='text'`` upon registering them with the ``Measurement``
object.

Note that the order of string values on the axis of the plot is exactly
the same as the order with which the values were added to the dataset.

.. code:: ipython3

    two_qubit_corr = Parameter('two_qubit_corr', label='2-qubit correlator',
                               set_cmd=None, get_cmd=None)
    
    two_q_corr_values = ['X_X', 'X_Y', 'X_Z',
                         'X_I', 'Y_Y', 'Y_Z',
                         'Y_I', 'Z_Z', 'Z_I']
    
    meas = Measurement()
    meas.register_parameter(two_qubit_corr, paramtype='text')
    meas.register_parameter(z, setpoints=(two_qubit_corr,))
    
    with meas.run() as datasaver:
    
        values = np.random.randn(len(two_q_corr_values))
        for two_q_corr_id, value in zip(two_q_corr_values, values):
            datasaver.add_result((two_qubit_corr, two_q_corr_id),
                                 (z, value))
    
    run_id_strings = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 7


.. code:: ipython3

    axes, colorbars = plot_by_id(run_id_strings)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='559733a3-5367-45be-948b-194f08b3bafb'></div>


String-valued dependent value
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In this example, let's plot the case where string-valued parameter is
the dependent one.

.. code:: ipython3

    meas = Measurement()
    meas.register_parameter(z)
    meas.register_parameter(two_qubit_corr, paramtype='text',
                            setpoints=(z,))
    
    
    with meas.run() as datasaver:
    
        values = np.random.randn(len(two_q_corr_values))
        for two_q_corr_id, value in zip(two_q_corr_values, values):
            datasaver.add_result((two_qubit_corr, two_q_corr_id),
                                 (z, value))
    
    run_id_strings = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 8


.. code:: ipython3

    axes, colorbars = plot_by_id(run_id_strings)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='9d1c5329-cd8e-4faa-b43d-7d8a470b1cc3'></div>


2D case
~~~~~~~

At the moment, **2D plotting** of data that has **string-valued**
components is **not fully supported.** Moreover, choosing an apropriate
plot type for such cases will be revisited.

String-valued independent parameter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: ipython3

    two_q_corr_values = ['X_X', 'X_Y', 'X_Z',
                         'X_I', 'Y_Y', 'Y_Z',
                         'Y_I', 'Z_Z', 'Z_I']
    
    meas = Measurement()
    meas.register_parameter(two_qubit_corr, paramtype='text')
    meas.register_parameter(t)
    meas.register_parameter(z, setpoints=(t, two_qubit_corr))
    
    n_points = 20
    
    with meas.run() as datasaver:
        for correlator in two_q_corr_values:
            zvals = np.random.randint(1, 4, n_points)
            tvals = np.random.rand(n_points)
            for tval, zval in zip(tvals, zvals):
                datasaver.add_result((two_qubit_corr, correlator),
                                     (t, tval), (z, zval))
    
    
    run_id_2d_strings = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 9


.. code:: ipython3

    axes, colorbars = plot_by_id(run_id_2d_strings)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='f306b450-7ecb-4143-bd7e-980907b7339e'></div>


String-valued dependent parameter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This case may produce **incorrect** plots, see an example below.

.. code:: ipython3

    two_q_corr_values = ['X_X', 'X_Y', 'X_Z',
                         'X_I', 'Y_Y', 'Y_Z',
                         'Y_I', 'Z_Z', 'Z_I']
    
    meas = Measurement()
    meas.register_parameter(t)
    meas.register_parameter(z)
    meas.register_parameter(two_qubit_corr, setpoints=(t, z),
                            paramtype='text')
    
    n_points = 20
    
    with meas.run() as datasaver:
        for zval, correlator in enumerate(two_q_corr_values):
            tvals = np.random.rand(n_points)
            for tval in tvals:
                datasaver.add_result((two_qubit_corr, correlator),
                                     (t, tval), (z, zval))
    
    
    run_id_2d_strings = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 10


.. code:: ipython3

    axes, colorbars = plot_by_id(run_id_2d_strings)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='1e46b219-d912-4f1d-ba59-209419eb497c'></div>


Fancy plotting
--------------

As a final example, let us combine several plots in one window.

We first make a little grid of axes.

.. code:: ipython3

    fig, figaxes = plt.subplots(2, 2)



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='b6f5b369-9232-42c9-b954-17030bfbc7a7'></div>


Next, we make some runs (shamelessly copy-pasting from above).

.. code:: ipython3

    # First run
    meas = Measurement()
    meas.register_parameter(x)
    meas.register_parameter(y, setpoints=(x,))
    
    xvals = np.linspace(-3.4, 4.2, 250)
    
    with meas.run() as datasaver:
        for xnum in xvals:
            noise = np.random.randn()*0.1  # multiplicative noise yeah yeah
            datasaver.add_result((x, xnum),
                                 (y, 2*(xnum+noise)**3 - 5*(xnum+noise)**2))
    
    rid1 = datasaver.run_id
    
    # Second run
    
    meas = Measurement()
    
    meas.register_parameter(x)
    meas.register_parameter(t)
    meas.register_parameter(z, setpoints=(x, t))
    
    xvals = np.linspace(-4, 5, 50)
    tvals = np.linspace(-500, 1500, 25)
    
    with meas.run() as datasaver:
        for xv in xvals:
            for tv in tvals:
                # just some arbitrary semi good looking function
                zv = np.sin(2*np.pi*xv)*np.cos(2*np.pi*0.001*tv) + 0.001*tv
                datasaver.add_result((x, xv), (t, tv), (z, zv))
    
    rid2 = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 11
    Starting experimental run with id: 12


And then we put them just where we please.

.. code:: ipython3

    axes, colorbars = plot_by_id(rid1, figaxes[0, 0])

.. code:: ipython3

    axes, colorbars = plot_by_id(rid2, figaxes[1, 1], colorbars)

Note that if we want to replot on an axis with a colorbar we probably
also want to reuse the colorbar

.. code:: ipython3

    axes, colorbars = plot_by_id(rid2, figaxes[1, 1], colorbars)

.. code:: ipython3

    fig.tight_layout()

Rasterizing
-----------

By default Matplotlib renders each individual data point as a separate
square in 2D plots when storing in a vector format (pdf,svg). This is
not a problem for small data sets. However the time needed to generate a
pdf increases rapidly with the number of data points. ``plot_by_id``
therefor will automatically rasterize the data (lines, ticks and labels
are still stirred as text) if more than 5000 data points are plotted.
The threshold value can be tweaked from the ``qcodesrc.json`` config
file.

Alternatively the rasterized keyword can be passed to the
``plot_by_id_function``

.. code:: ipython3

    meas = Measurement()
    
    meas.register_parameter(x)
    meas.register_parameter(t)
    meas.register_parameter(z, setpoints=(x, t))
    
    xvals = np.linspace(-4, 5, 100)
    tvals = np.linspace(-500, 1500, 500)
    
    with meas.run() as datasaver:
        for xv in xvals:
            for tv in tvals:
                # just some arbitrary semi good looking function
                zv = np.sin(2*np.pi*xv)*np.cos(2*np.pi*0.001*tv) + 0.001*tv
                datasaver.add_result((x, xv), (t, tv), (z, zv))
    
    dataid = datasaver.run_id


.. parsed-literal::

    Starting experimental run with id: 13


To get a feeling of how slow this can be try replacing the
``plot_by_id`` function below with the non rasterized version commented
out.

.. code:: ipython3

    %%time
    axeslist, _ = plot_by_id(dataid)
    # axeslist, _ = plot_by_id(dataid, rasterized=False)
    axeslist[0].figure.savefig(f'test_plot_by_id_{dataid}.pdf')



.. parsed-literal::

    <IPython.core.display.Javascript object>



.. raw:: html

    <div id='02ea0b5d-a58f-47fa-a38a-dae1ec8f100e'></div>


.. parsed-literal::

    CPU times: user 966 ms, sys: 124 ms, total: 1.09 s
    Wall time: 968 ms


