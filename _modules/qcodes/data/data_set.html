

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>qcodes.data.data_set &mdash; QCoDeS 0.1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="QCoDeS 0.1.0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> QCoDeS
          

          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../community/index.html">Community Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">Classes and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../roadmap.html">Qcodes project plan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changes/index.html">Changelogs</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">QCoDeS</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>qcodes.data.data_set</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for qcodes.data.data_set</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;DataSet class and factory functions.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">traceback</span> <span class="kn">import</span> <span class="n">format_exc</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="kn">from</span> <span class="nn">.manager</span> <span class="kn">import</span> <span class="n">get_data_manager</span><span class="p">,</span> <span class="n">NoData</span>
<span class="kn">from</span> <span class="nn">.gnuplot_format</span> <span class="kn">import</span> <span class="n">GNUPlotFormat</span>
<span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">DiskIO</span>
<span class="kn">from</span> <span class="nn">.location</span> <span class="kn">import</span> <span class="n">FormatLocation</span>
<span class="kn">from</span> <span class="nn">qcodes.utils.helpers</span> <span class="kn">import</span> <span class="n">DelegateAttributes</span><span class="p">,</span> <span class="n">full_class</span><span class="p">,</span> <span class="n">deep_update</span>


<div class="viewcode-block" id="DataMode"><a class="viewcode-back" href="../../../api/generated/qcodes.DataMode.html#qcodes.DataMode">[docs]</a><span class="k">class</span> <span class="nc">DataMode</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Server connection modes supported by a DataSet.&quot;&quot;&quot;</span>

    <span class="n">LOCAL</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">PUSH_TO_SERVER</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">PULL_FROM_SERVER</span> <span class="o">=</span> <span class="mi">3</span></div>


<span class="n">SERVER_MODES</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">DataMode</span><span class="o">.</span><span class="n">PULL_FROM_SERVER</span><span class="p">,</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">PUSH_TO_SERVER</span><span class="p">))</span>


<div class="viewcode-block" id="new_data"><a class="viewcode-back" href="../../../api/generated/qcodes.new_data.html#qcodes.new_data">[docs]</a><span class="k">def</span> <span class="nf">new_data</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">loc_record</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">io</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">data_manager</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">DataMode</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new DataSet.</span>

<span class="sd">    Args:</span>
<span class="sd">        location (str or callable or False, optional): If you provide a string,</span>
<span class="sd">            it must be an unused location in the io manager. Can also be:</span>
<span class="sd">            - a callable ``location provider`` with one required parameter</span>
<span class="sd">              (the io manager), and one optional (``record`` dict),</span>
<span class="sd">              which returns a location string when called</span>
<span class="sd">            - ``False`` - denotes an only-in-memory temporary DataSet.</span>
<span class="sd">            Note that the full path to or physical location of the data is a</span>
<span class="sd">            combination of io + location. the default ``DiskIO`` sets the base</span>
<span class="sd">            directory, which this location is a relative path inside.</span>
<span class="sd">            Default ``DataSet.location_provider`` which is initially</span>
<span class="sd">            ``FormatLocation()``</span>

<span class="sd">        loc_record (dict, optional): If location is a callable, this will be</span>
<span class="sd">            passed to it as ``record``</span>

<span class="sd">        name (str, optional): overrides the ``name`` key in the ``loc_record``.</span>

<span class="sd">        overwrite (bool): Are we allowed to overwrite an existing location?</span>
<span class="sd">            Default False.</span>

<span class="sd">        io (io_manager, optional): base physical location of the ``DataSet``.</span>
<span class="sd">            Default ``DataSet.default_io`` is initially ``DiskIO(&#39;.&#39;)`` which</span>
<span class="sd">            says the root data directory is the current working directory, ie</span>
<span class="sd">            where you started the python session.</span>

<span class="sd">        data_manager (DataManager or False, optional): manager for the</span>
<span class="sd">            ``DataServer`` that offloads storage and syncing of this</span>
<span class="sd">            ``DataSet``. Usually omitted (default None) to use the default</span>
<span class="sd">            from ``get_data_manager()``. If ``False``, this ``DataSet`` will</span>
<span class="sd">            store itself.</span>

<span class="sd">        mode (DataMode, optional): connection type to the ``DataServer``.</span>
<span class="sd">            ``DataMode.LOCAL``: this DataSet doesn&#39;t communicate across</span>
<span class="sd">                processes.</span>
<span class="sd">            ``DataMode.PUSH_TO_SERVER``: no local copy of data, just pushes</span>
<span class="sd">                each measurement to a ``DataServer``.</span>
<span class="sd">            ``DataMode.PULL_FROM_SERVER``: pulls changes from the</span>
<span class="sd">                ``DataServer`` on calling ``self.sync()``. Reverts to local if</span>
<span class="sd">                and when it stops being the live measurement.</span>
<span class="sd">            Default ``DataMode.LOCAL``.</span>

<span class="sd">        arrays (dict, optional): dict of ``array_id: DataArray``, can also be</span>
<span class="sd">            added later with ``self.add_array(array)``.</span>

<span class="sd">        formatter (Formatter, optional): sets the file format/structure to</span>
<span class="sd">            write (and read) with. Default ``DataSet.default_formatter`` which</span>
<span class="sd">            is initially ``GNUPlotFormat()``.</span>

<span class="sd">        write_period (float or None, optional): Only if ``mode=LOCAL``, seconds</span>
<span class="sd">            between saves to disk. If not ``LOCAL``, the ``DataServer`` handles</span>
<span class="sd">            this and generally writes more often. Use None to disable writing</span>
<span class="sd">            from calls to ``self.store``. Default 5.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A new ``DataSet`` object ready for storing new data in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">io</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">io</span> <span class="o">=</span> <span class="n">DataSet</span><span class="o">.</span><span class="n">default_io</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">loc_record</span><span class="p">:</span>
            <span class="n">loc_record</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">loc_record</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">DataSet</span><span class="o">.</span><span class="n">location_provider</span>

    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">location</span><span class="p">):</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">location</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="n">loc_record</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">location</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">overwrite</span><span class="p">)</span> <span class="ow">and</span> <span class="n">io</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="n">location</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">FileExistsError</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="n">location</span> <span class="o">+</span> <span class="s1">&#39;&quot; already has data&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">data_manager</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;DataSets without a data_manager must be local&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">data_manager</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">data_manager</span> <span class="o">=</span> <span class="n">get_data_manager</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">DataSet</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span> <span class="n">io</span><span class="o">=</span><span class="n">io</span><span class="p">,</span> <span class="n">data_manager</span><span class="o">=</span><span class="n">data_manager</span><span class="p">,</span>
                   <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="load_data"><a class="viewcode-back" href="../../../api/generated/qcodes.load_data.html#qcodes.load_data">[docs]</a><span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">data_manager</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">io</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load an existing DataSet.</span>

<span class="sd">    The resulting ``DataSet.mode`` is determined automatically from location:</span>
<span class="sd">    PULL_FROM_SERVER if this is the live DataSet, otherwise LOCAL</span>

<span class="sd">    Args:</span>
<span class="sd">        location (str, optional): the location to load from. Default is the</span>
<span class="sd">            current live DataSet.</span>
<span class="sd">            Note that the full path to or physical location of the data is a</span>
<span class="sd">            combination of io + location. the default ``DiskIO`` sets the base</span>
<span class="sd">            directory, which this location is a relative path inside.</span>

<span class="sd">        data_manager (DataManager or False, optional): manager for the</span>
<span class="sd">            ``DataServer`` that offloads storage and syncing of this</span>
<span class="sd">            ``DataSet``. Usually omitted (default None) to use the default</span>
<span class="sd">            from ``get_data_manager()``. If ``False``, this ``DataSet`` will</span>
<span class="sd">            store itself. ``load_data`` will not start a DataManager but may</span>
<span class="sd">            query an existing one to determine (and pull) the live data.</span>

<span class="sd">        formatter (Formatter, optional): sets the file format/structure to</span>
<span class="sd">            read with. Default ``DataSet.default_formatter`` which</span>
<span class="sd">            is initially ``GNUPlotFormat()``.</span>

<span class="sd">        io (io_manager, optional): base physical location of the ``DataSet``.</span>
<span class="sd">            Default ``DataSet.default_io`` is initially ``DiskIO(&#39;.&#39;)`` which</span>
<span class="sd">            says the root data directory is the current working directory, ie</span>
<span class="sd">            where you started the python session.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A new ``DataSet`` object loaded with pre-existing data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">data_manager</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">data_manager</span> <span class="o">=</span> <span class="n">get_data_manager</span><span class="p">(</span><span class="n">only_existing</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data_manager</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Live data requested but DataManager does &#39;</span>
                               <span class="s1">&#39;not exist or was requested not to be used&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_get_live_data</span><span class="p">(</span><span class="n">data_manager</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;location=False means a temporary DataSet, &#39;</span>
                         <span class="s1">&#39;which is incompatible with load_data&#39;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="p">(</span><span class="n">data_manager</span> <span class="ow">and</span>
            <span class="n">location</span> <span class="o">==</span> <span class="n">data_manager</span><span class="o">.</span><span class="n">ask</span><span class="p">(</span><span class="s1">&#39;get_data&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">_get_live_data</span><span class="p">(</span><span class="n">data_manager</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">DataSet</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">,</span> <span class="n">io</span><span class="o">=</span><span class="n">io</span><span class="p">,</span>
                       <span class="n">mode</span><span class="o">=</span><span class="n">DataMode</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">read_metadata</span><span class="p">()</span>
        <span class="n">data</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span></div>


<span class="k">def</span> <span class="nf">_get_live_data</span><span class="p">(</span><span class="n">data_manager</span><span class="p">):</span>
    <span class="n">live_data</span> <span class="o">=</span> <span class="n">data_manager</span><span class="o">.</span><span class="n">ask</span><span class="p">(</span><span class="s1">&#39;get_data&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">live_data</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">live_data</span><span class="p">,</span> <span class="n">NoData</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;DataManager has no live data&#39;</span><span class="p">)</span>

    <span class="n">live_data</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">PULL_FROM_SERVER</span>
    <span class="k">return</span> <span class="n">live_data</span>


<div class="viewcode-block" id="DataSet"><a class="viewcode-back" href="../../../api/generated/qcodes.DataSet.html#qcodes.DataSet">[docs]</a><span class="k">class</span> <span class="nc">DataSet</span><span class="p">(</span><span class="n">DelegateAttributes</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A container for one complete measurement loop.</span>

<span class="sd">    May contain many individual arrays with potentially different</span>
<span class="sd">    sizes and dimensionalities.</span>

<span class="sd">    Normally a DataSet should not be instantiated directly, but through</span>
<span class="sd">    ``new_data`` or ``load_data``.</span>

<span class="sd">    Args:</span>
<span class="sd">        location (str or False): A location in the io manager, or ``False`` for</span>
<span class="sd">            an only-in-memory temporary DataSet.</span>
<span class="sd">            Note that the full path to or physical location of the data is a</span>
<span class="sd">            combination of io + location. the default ``DiskIO`` sets the base</span>
<span class="sd">            directory, which this location is a relative path inside.</span>

<span class="sd">        io (io_manager, optional): base physical location of the ``DataSet``.</span>
<span class="sd">            Default ``DataSet.default_io`` is initially ``DiskIO(&#39;.&#39;)`` which</span>
<span class="sd">            says the root data directory is the current working directory, ie</span>
<span class="sd">            where you started the python session.</span>

<span class="sd">        data_manager (DataManager or False, optional): manager for the</span>
<span class="sd">            ``DataServer`` that offloads storage and syncing of this</span>
<span class="sd">            ``DataSet``. Usually omitted (default None) to use the default</span>
<span class="sd">            from ``get_data_manager()``. If ``False``, this ``DataSet`` will</span>
<span class="sd">            store itself.</span>

<span class="sd">        mode (DataMode, optional): connection type to the ``DataServer``.</span>
<span class="sd">            ``DataMode.LOCAL``: this DataSet doesn&#39;t communicate across</span>
<span class="sd">                processes.</span>
<span class="sd">            ``DataMode.PUSH_TO_SERVER``: no local copy of data, just pushes</span>
<span class="sd">                each measurement to a ``DataServer``.</span>
<span class="sd">            ``DataMode.PULL_FROM_SERVER``: pulls changes from the</span>
<span class="sd">                ``DataServer`` on calling ``self.sync()``. Reverts to local if</span>
<span class="sd">                and when it stops being the live measurement.</span>
<span class="sd">            Default ``DataMode.LOCAL``.</span>

<span class="sd">        arrays (dict, optional): dict of ``array_id: DataArray``, can also be</span>
<span class="sd">            added later with ``self.add_array(array)``.</span>

<span class="sd">        formatter (Formatter, optional): sets the file format/structure to</span>
<span class="sd">            write (and read) with. Default ``DataSet.default_formatter`` which</span>
<span class="sd">            is initially ``GNUPlotFormat()``.</span>

<span class="sd">        write_period (float or None, optional): Only if ``mode=LOCAL``, seconds</span>
<span class="sd">            between saves to disk. If not ``LOCAL``, the ``DataServer`` handles</span>
<span class="sd">            this and generally writes more often. Use None to disable writing</span>
<span class="sd">            from calls to ``self.store``. Default 5.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        background_functions (OrderedDict[callable]): Class attribute,</span>
<span class="sd">            ``{key: fn}``: ``fn`` is a callable accepting no arguments, and</span>
<span class="sd">            ``key`` is a name to identify the function and help you attach and</span>
<span class="sd">            remove it.</span>

<span class="sd">            In ``DataSet.complete`` we call each of these periodically, in the</span>
<span class="sd">            order that they were attached.</span>

<span class="sd">            Note that because this is a class attribute, the functions will</span>
<span class="sd">            apply to every DataSet. If you want specific functions for one</span>
<span class="sd">            DataSet you can override this with an instance attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ie data_set.arrays[&#39;vsd&#39;] === data_set.vsd</span>
    <span class="n">delegate_attr_dicts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;arrays&#39;</span><span class="p">]</span>

    <span class="n">default_io</span> <span class="o">=</span> <span class="n">DiskIO</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
    <span class="n">default_formatter</span> <span class="o">=</span> <span class="n">GNUPlotFormat</span><span class="p">()</span>
    <span class="n">location_provider</span> <span class="o">=</span> <span class="n">FormatLocation</span><span class="p">()</span>

    <span class="n">background_functions</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

<div class="viewcode-block" id="DataSet.__init__"><a class="viewcode-back" href="../../../api/generated/qcodes.DataSet.html#qcodes.DataSet.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">DataMode</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">,</span> <span class="n">arrays</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">data_manager</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">io</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">write_period</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">location</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unrecognized location &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">location</span><span class="p">))</span>

        <span class="c1"># TODO: when you change formatter or io (and there&#39;s data present)</span>
        <span class="c1"># make it all look unsaved</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span> <span class="o">=</span> <span class="n">formatter</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_formatter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_io</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write_period</span> <span class="o">=</span> <span class="n">write_period</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_write</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">arrays</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">action_id_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clean_array_ids</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data_manager</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">SERVER_MODES</span><span class="p">:</span>
            <span class="n">data_manager</span> <span class="o">=</span> <span class="n">get_data_manager</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_local</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">PUSH_TO_SERVER</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_push_to_server</span><span class="p">(</span><span class="n">data_manager</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">PULL_FROM_SERVER</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_live</span><span class="p">(</span><span class="n">data_manager</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unrecognized DataSet mode&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_init_local</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">LOCAL</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">array</span><span class="o">.</span><span class="n">init_data</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_init_push_to_server</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_manager</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">PUSH_TO_SERVER</span>

        <span class="c1"># If some code was not available when data_manager was started,</span>
        <span class="c1"># we can&#39;t unpickle it on the other end.</span>
        <span class="c1"># So we&#39;ll try, then restart if this error occurs, then try again.</span>
        <span class="c1">#</span>
        <span class="c1"># This still has a pitfall, if code has been *changed* since</span>
        <span class="c1"># starting the server, it will still have the old version and</span>
        <span class="c1"># everything will look fine but it won&#39;t have the new behavior.</span>
        <span class="c1"># If the user does that, they need to manually restart the server,</span>
        <span class="c1"># using:</span>
        <span class="c1">#     data_manager.restart()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data_manager</span><span class="o">.</span><span class="n">ask</span><span class="p">(</span><span class="s1">&#39;new_data&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">data_manager</span><span class="o">.</span><span class="n">restart</span><span class="p">()</span>
            <span class="n">data_manager</span><span class="o">.</span><span class="n">ask</span><span class="p">(</span><span class="s1">&#39;new_data&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># need to set data_manager *after* sending to data_manager because</span>
        <span class="c1"># we can&#39;t (and shouldn&#39;t) send data_manager itself through a queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_manager</span> <span class="o">=</span> <span class="n">data_manager</span>

    <span class="k">def</span> <span class="nf">init_on_server</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure this DataSet as the DataServer copy.</span>

<span class="sd">        Should be run only by the DataServer itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;A server-side DataSet needs DataArrays.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_local</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_init_live</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_manager</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">PULL_FROM_SERVER</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_manager</span> <span class="o">=</span> <span class="n">data_manager</span>
        <span class="k">with</span> <span class="n">data_manager</span><span class="o">.</span><span class="n">query_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_on_server</span><span class="p">:</span>
                <span class="n">live_obj</span> <span class="o">=</span> <span class="n">data_manager</span><span class="o">.</span><span class="n">ask</span><span class="p">(</span><span class="s1">&#39;get_data&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span> <span class="o">=</span> <span class="n">live_obj</span><span class="o">.</span><span class="n">arrays</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_init_local</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_live_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicate whether this DataSet thinks it is live in the DataServer.</span>

<span class="sd">        Does not actually talk to the DataServer or sync with it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="ow">in</span> <span class="n">SERVER_MODES</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_manager</span> <span class="ow">and</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_on_server</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether this DataSet is actually live in the DataServer.</span>

<span class="sd">        If it thought it was but isn&#39;t, convert it to mode=LOCAL</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_live_mode</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_manager</span><span class="o">.</span><span class="n">query_lock</span><span class="p">:</span>
            <span class="n">live_location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_manager</span><span class="o">.</span><span class="n">ask</span><span class="p">(</span><span class="s1">&#39;get_data&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">==</span> <span class="n">live_location</span>

    <span class="k">def</span> <span class="nf">sync</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronize this DataSet with the DataServer or storage.</span>

<span class="sd">        If this DataSet is on the server, asks the server for changes.</span>
<span class="sd">        If not, reads the entire DataSet from disk.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if this DataSet is live on the server</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: sync implies bidirectional... and it could be!</span>
        <span class="c1"># we should keep track of last sync timestamp and last modification</span>
        <span class="c1"># so we can tell whether this one, the other one, or both copies have</span>
        <span class="c1"># changed (and I guess throw an error if both did? Would be cool if we</span>
        <span class="c1"># could find a robust and intuitive way to make modifications to the</span>
        <span class="c1"># version on the DataServer from the main copy)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_live_mode</span><span class="p">:</span>
            <span class="c1"># LOCAL DataSet - just read it in</span>
            <span class="c1"># TODO: compare timestamps to know if we need to read?</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="c1"># if no files exist, they probably haven&#39;t been created yet.</span>
                <span class="k">pass</span>
            <span class="k">return</span> <span class="bp">False</span>
            <span class="c1"># TODO - for remote live plotting, maybe set some timestamp</span>
            <span class="c1"># threshold and call it static after it&#39;s been dormant a long time?</span>
            <span class="c1"># I&#39;m thinking like a minute, or ten? Maybe it&#39;s configurable?</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_manager</span><span class="o">.</span><span class="n">query_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_on_server</span><span class="p">:</span>
                <span class="n">synced_indices</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">array_id</span><span class="p">:</span> <span class="n">array</span><span class="o">.</span><span class="n">get_synced_index</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">array_id</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>

                <span class="n">changes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_manager</span><span class="o">.</span><span class="n">ask</span><span class="p">(</span><span class="s1">&#39;get_changes&#39;</span><span class="p">,</span> <span class="n">synced_indices</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">array_id</span><span class="p">,</span> <span class="n">array_changes</span> <span class="ow">in</span> <span class="n">changes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">array_id</span><span class="p">]</span><span class="o">.</span><span class="n">apply_changes</span><span class="p">(</span><span class="o">**</span><span class="n">array_changes</span><span class="p">)</span>

                <span class="n">measuring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_manager</span><span class="o">.</span><span class="n">ask</span><span class="p">(</span><span class="s1">&#39;get_measuring&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">measuring</span><span class="p">:</span>
                    <span class="c1"># we must have *just* stopped measuring</span>
                    <span class="c1"># but the DataSet is still on the server,</span>
                    <span class="c1"># so we got the data, and don&#39;t need to read.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">LOCAL</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this DataSet *thought* it was on the server, but it wasn&#39;t,</span>
                <span class="c1"># so we haven&#39;t synced yet and need to read from storage</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">LOCAL</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">fraction_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the fraction of this DataSet which has data in it.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: the average of all measured (not setpoint) arrays&#39;</span>
<span class="sd">                ``fraction_complete()`` values, independent of the individual</span>
<span class="sd">                array sizes. If there are no measured arrays, returns zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">array_count</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">array</span><span class="o">.</span><span class="n">is_setpoint</span><span class="p">:</span>
                <span class="n">array_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">array</span><span class="o">.</span><span class="n">fraction_complete</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">total</span> <span class="o">/</span> <span class="p">(</span><span class="n">array_count</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Periodically sync the DataSet and display percent complete status.</span>

<span class="sd">        Also, each period, execute functions stored in (class attribute)</span>
<span class="sd">        ``self.background_functions``. If a function fails, we log its</span>
<span class="sd">        traceback and continue on. If any one function fails twice in</span>
<span class="sd">        a row, it gets removed.</span>

<span class="sd">        Args:</span>
<span class="sd">            delay (float): seconds between iterations. Default 1.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s1">&#39;waiting for DataSet &lt;{}&gt; to complete&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">))</span>

        <span class="n">failing</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">False</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">background_functions</span><span class="p">}</span>

        <span class="n">nloops</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">completed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">completed</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;DataSet: {:.0f}</span><span class="si">% c</span><span class="s1">omplete&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fraction_complete</span><span class="p">()</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>

            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
            <span class="n">nloops</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">completed</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">fn</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">background_functions</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;calling {}: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">fn</span><span class="p">)))</span>
                    <span class="n">fn</span><span class="p">()</span>
                    <span class="n">failing</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">format_exc</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">failing</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s1">&#39;background function {} failed twice in a row, &#39;</span>
                            <span class="s1">&#39;removing it&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">background_functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="n">failing</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;DataSet &lt;{}&gt; is complete&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_changes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synced_indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find changes since the last sync of this DataSet.</span>

<span class="sd">        Args:</span>
<span class="sd">            synced_indices (dict): ``{array_id: synced_index}`` where</span>
<span class="sd">                synced_index is the last flat index which has already</span>
<span class="sd">                been synced, for any (usually all) arrays in the DataSet.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict[dict]: keys are ``array_id`` for each array with changes,</span>
<span class="sd">                values are dicts as returned by ``DataArray.get_changes``</span>
<span class="sd">                and required as kwargs to ``DataArray.apply_changes``.</span>
<span class="sd">                Note that not all arrays in ``synced_indices`` need be</span>
<span class="sd">                present in the return, only those with changes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">array_id</span><span class="p">,</span> <span class="n">synced_index</span> <span class="ow">in</span> <span class="n">synced_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">array_changes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">array_id</span><span class="p">]</span><span class="o">.</span><span class="n">get_changes</span><span class="p">(</span><span class="n">synced_index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">array_changes</span><span class="p">:</span>
                <span class="n">changes</span><span class="p">[</span><span class="n">array_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_changes</span>

        <span class="k">return</span> <span class="n">changes</span>

    <span class="k">def</span> <span class="nf">add_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add one DataArray to this DataSet, and mark it as part of this DataSet.</span>

<span class="sd">        Note: DO NOT just set ``data_set.arrays[id] = data_array``, because</span>
<span class="sd">        this will not check if we are overwriting another array, nor set the</span>
<span class="sd">        reference back to this DataSet, nor that the ``array_id`` in the array</span>
<span class="sd">        matches how you&#39;re storing it here.</span>

<span class="sd">        Args:</span>
<span class="sd">            data_array (DataArray): the new array to add</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if there is already an array with this id here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: mask self.arrays so you *can&#39;t* set it directly?</span>

        <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">array_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;array_id {} already exists in this &#39;</span>
                             <span class="s1">&#39;DataSet&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">array_id</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">data_array</span><span class="o">.</span><span class="n">array_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_array</span>

        <span class="c1"># back-reference to the DataSet</span>
        <span class="n">data_array</span><span class="o">.</span><span class="n">data_set</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_clean_array_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrays</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        replace action_indices tuple with compact string array_ids</span>
<span class="sd">        stripping off as much extraneous info as possible</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">action_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="o">.</span><span class="n">action_indices</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">full_name</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">is_setpoint</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;_set&#39;</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;_set&#39;</span>

            <span class="n">array</span><span class="o">.</span><span class="n">array_id</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">array_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">array</span><span class="o">.</span><span class="n">array_id</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">array_ids</span><span class="p">:</span>
            <span class="n">param_arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span>
                            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">array_id</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clean_param_ids</span><span class="p">(</span><span class="n">param_arrays</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="n">array_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="o">.</span><span class="n">array_id</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">action_indices</span><span class="p">,</span> <span class="n">array_ids</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_clean_param_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># strip off as many leading equal indices as possible</span>
        <span class="c1"># and append the rest to the back of the name with underscores</span>
        <span class="n">param_action_indices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">action_indices</span><span class="p">)</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span> <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">param_action_indices</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ai</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">param_action_indices</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">param_action_indices</span><span class="p">:</span>
                    <span class="n">ai</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">for</span> <span class="n">array</span><span class="p">,</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">param_action_indices</span><span class="p">):</span>
            <span class="n">array</span><span class="o">.</span><span class="n">array_id</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ai</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop_indices</span><span class="p">,</span> <span class="n">ids_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert data into one or more of our DataArrays.</span>

<span class="sd">        If in ``PUSH_TO_SERVER`` mode, this is where we do that!</span>
<span class="sd">        Otherwise we also periodically trigger a write to storage.</span>

<span class="sd">        Args:</span>
<span class="sd">            loop_indices (tuple): the indices within whatever loops we are</span>
<span class="sd">                inside. May have fewer dimensions than some of the arrays</span>
<span class="sd">                we are inserting into, if the corresponding value makes up</span>
<span class="sd">                the remaining dimensionality.</span>
<span class="sd">            values (Dict[Union[float, sequence]]): a dict whose keys are</span>
<span class="sd">                array_ids, and values are single numbers or entire slices</span>
<span class="sd">                to insert into that array.</span>
<span class="sd">         &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">PUSH_TO_SERVER</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_manager</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;store_data&#39;</span><span class="p">,</span> <span class="n">loop_indices</span><span class="p">,</span> <span class="n">ids_values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">array_id</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">ids_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">array_id</span><span class="p">][</span><span class="n">loop_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">write_period</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_write</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_period</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">last_write</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the whole DataSet from storage, overwriting the local data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the metadata from storage, overwriting the local data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">read_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write updates to the DataSet to storage.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;This object is connected to a DataServer, &#39;</span>
                               <span class="s1">&#39;which handles writing automatically.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">io_manager</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a new complete copy of this DataSet to storage.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, optional): An absolute path on this system to write to.</span>
<span class="sd">                If you specify this, you may not include either ``io_manager``</span>
<span class="sd">                or ``location``.</span>

<span class="sd">            io_manager (io_manager, optional): A new ``io_manager`` to use with</span>
<span class="sd">                either the ``DataSet``&#39;s same or a new ``location``.</span>

<span class="sd">            location (str, optional): A new ``location`` to write to, using</span>
<span class="sd">                either this ``DataSet``&#39;s same or a new ``io_manager``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">io_manager</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;If you provide io_manager or location &#39;</span>
                                <span class="s1">&#39;to write_copy, you may not provide path.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">io_manager</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">io_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span>
            <span class="k">elif</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span>
        <span class="k">elif</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">io_manager</span> <span class="o">=</span> <span class="n">DiskIO</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;You must provide at least one argument &#39;</span>
                            <span class="s1">&#39;to write_copy&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;write_copy needs a location, not False&#39;</span><span class="p">)</span>

        <span class="n">lsi_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">mr_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">array_id</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">lsi_cache</span><span class="p">[</span><span class="n">array_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">last_saved_index</span>
            <span class="n">mr_cache</span><span class="p">[</span><span class="n">array_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">modified_range</span>
            <span class="c1"># array.clear_save() is not enough, we _need_ to set modified_range</span>
            <span class="c1"># TODO - identify *when* clear_save is not enough, and fix it</span>
            <span class="c1"># so we *can* use it. That said, maybe we will *still* want to</span>
            <span class="c1"># use the full array here no matter what, or strip trailing NaNs</span>
            <span class="c1"># separately, either here or in formatter.write?</span>
            <span class="n">array</span><span class="o">.</span><span class="n">last_saved_index</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">array</span><span class="o">.</span><span class="n">modified_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">io_manager</span><span class="p">,</span> <span class="n">location</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snapshot</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">write_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">io_manager</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span>
                                          <span class="n">read_first</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">array_id</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">array</span><span class="o">.</span><span class="n">last_saved_index</span> <span class="o">=</span> <span class="n">lsi_cache</span><span class="p">[</span><span class="n">array_id</span><span class="p">]</span>
                <span class="n">array</span><span class="o">.</span><span class="n">modified_range</span> <span class="o">=</span> <span class="n">mr_cache</span><span class="p">[</span><span class="n">array_id</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">add_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_metadata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update DataSet.metadata with additional data.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_metadata (dict): new data to be deep updated into</span>
<span class="sd">                the existing metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deep_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">new_metadata</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate and save the DataSet&#39;s metadata.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snapshot</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">write_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mark the DataSet complete and write any remaining modifications.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">PUSH_TO_SERVER</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_manager</span><span class="o">.</span><span class="n">ask</span><span class="p">(</span><span class="s1">&#39;end_data&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">DataMode</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;This mode does not allow finalizing&#39;</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_metadata</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;JSON state of the DataSet.&quot;&quot;&quot;</span>
        <span class="n">array_snaps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">array_id</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">array_snaps</span><span class="p">[</span><span class="n">array_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">snapshot</span><span class="p">(</span><span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;__class__&#39;</span><span class="p">:</span> <span class="n">full_class</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="s1">&#39;location&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
            <span class="s1">&#39;arrays&#39;</span><span class="p">:</span> <span class="n">array_snaps</span><span class="p">,</span>
            <span class="s1">&#39;formatter&#39;</span><span class="p">:</span> <span class="n">full_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="p">),</span>
            <span class="s1">&#39;io&#39;</span><span class="p">:</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_array_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the metadata for a single contained DataArray.</span>

<span class="sd">        Args:</span>
<span class="sd">            array_id (str): the array to get metadata for.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: metadata for this array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;arrays&#39;</span><span class="p">][</span><span class="n">array_id</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rich information about the DataSet and contained arrays.&quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span>

        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">],</span>
                 <span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">)]]</span>
        <span class="n">attr_template</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">   {:8} = {}&#39;</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">attr_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="n">arr_info</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;&lt;Type&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;array_id&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;array.name&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;array.shape&gt;&#39;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;action_id_map&#39;</span><span class="p">):</span>
            <span class="n">id_items</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">item</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">action_id_map</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">id_items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">array_id</span> <span class="ow">in</span> <span class="n">id_items</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">array_id</span><span class="p">]</span>
            <span class="n">setp</span> <span class="o">=</span> <span class="s1">&#39;Setpoint&#39;</span> <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">is_setpoint</span> <span class="k">else</span> <span class="s1">&#39;Measured&#39;</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;None&#39;</span>
            <span class="n">array_id</span> <span class="o">=</span> <span class="n">array_id</span> <span class="ow">or</span> <span class="s1">&#39;None&#39;</span>
            <span class="n">arr_info</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">setp</span><span class="p">,</span> <span class="n">array_id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)])</span>

        <span class="n">column_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">arr_info</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span>
        <span class="n">out_template</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">   &#39;</span>
                        <span class="s1">&#39;{info[0]:{lens[0]}} | {info[1]:{lens[1]}} | &#39;</span>
                        <span class="s1">&#39;{info[2]:{lens[2]}} | {info[3]}&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">arr_info_i</span> <span class="ow">in</span> <span class="n">arr_info</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">out_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">arr_info_i</span><span class="p">,</span> <span class="n">lens</span><span class="o">=</span><span class="n">column_lengths</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>